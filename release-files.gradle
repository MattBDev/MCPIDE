buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath group: 'com.googlecode.plist', name: 'dd-plist', version: '1.16'
    }
}

import com.dd.plist.NSDictionary
import com.dd.plist.NSString
import com.dd.plist.PropertyListParser

import java.nio.file.DirectoryNotEmptyException
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.StandardCopyOption
import java.nio.file.attribute.PosixFilePermissions

Zip distZipTask = (Zip) project.tasks.getByName("distZip")

def releasesFolderName = "releases"
def releasesBase = file("build/$releasesFolderName")

// apps are a directory
def appDir = releasesBase.toPath().resolve("${project.name}.app").resolve("Contents")
def appResources = appDir.resolve("Resources")
def appMacOs = appDir.resolve("MacOS")

def srcResources = file("release-resources").toPath()

class Methods {
    static Path copyIntoDir(Path from, Path dirTo) {
        Path pathTo = dirTo.resolve(from.fileName)
        Files.copy(from, pathTo, StandardCopyOption.REPLACE_EXISTING)
        return pathTo
    }
}

// NOTE: paths are broken with gradle -- don't ever pass them to gradle

project.task("macReleaseApp").configure {
    dependsOn distZipTask

    inputs.files(distZipTask.archivePath)
    outputs.dir(appDir.toFile())

    doFirst {
        // macOS app structure is like so
        // MCPIDE.app/Contents/
        //     MacOS/mcpide-bootstrap - script that calls script from distZip
        //     Resources/MCPIDE - MCPIDE-<version>.zip contents
        //     Resources/logo.png - Logo, data is stored in ./release-resources/
        //     Info.plist - macOS startup file, data is stored in ./release-resources/
        Files.createDirectories(appResources)
        Files.createDirectories(appMacOs)

        def resourceRoot = appResources.resolve(project.name)
        project.copy {
            from project.zipTree(distZipTask.archivePath)
            into resourceRoot.toFile()
        }
        // after copying zip content we must move it again
        // see https://github.com/gradle/gradle/issues/1108
        def baseDir = resourceRoot.resolve("${project.name}-${project.version}")

        try {
            Files.move(baseDir.resolve("bin"), appResources.resolve("bin"), StandardCopyOption.REPLACE_EXISTING)
        } catch (DirectoryNotEmptyException ignore) {
        }
        try {
            Files.move(baseDir.resolve("lib"), appResources.resolve("lib"), StandardCopyOption.REPLACE_EXISTING)
        } catch (DirectoryNotEmptyException ignore) {
        }
        resourceRoot.toFile().deleteDir()

        def infoPlistFile = Methods.copyIntoDir(srcResources.resolve("Info.plist"), appDir)
        Methods.copyIntoDir(srcResources.resolve("icon.icns"), appResources)
        def bootstrapScript = Methods.copyIntoDir(srcResources.resolve("mcpide-bootstrap"), appMacOs)

        // chmod 755 mcpide-bootstrap
        Files.setPosixFilePermissions(bootstrapScript, PosixFilePermissions.fromString("rwxr-xr-x"))

        // rewrite Info.plist with correct version
        NSDictionary infoPlist = (NSDictionary) PropertyListParser.parse(infoPlistFile.toFile())
        // GetInfo is basically version string
        infoPlist.put("CFBundleGetInfoString", new NSString("${project.version}"))
        PropertyListParser.saveAsXML(infoPlist, infoPlistFile.toFile())
    }
}

// make a shadow jar for Windows/Linux -- the gradle script is better for macOS
jar {
    manifest {
        attributes 'MainClass': project.property('mainClassName')
    }
}

Task createExe = project.tasks.getByName('createExe')
Task shadowJar = project.tasks.getByName('shadowJar')
createExe.dependsOn shadowJar

project.task('windowsReleaseExe').configure {
    dependsOn createExe
}
launch4j {
    mainClassName = project.property('mainClassName')
    icon = srcResources.resolve('icon.ico').toFile()
    outputDir = releasesFolderName // output to the build folder
    copyConfigurable = shadowJar.outputs.files
    jar = shadowJar.outputs.files.files.first()
    jreRuntimeBits = '64/32'

    // not using HTTPS should be a punishable crime
    downloadUrl = "https://java.com/download"

    fileDescription = "${project.name} ${project.version}"
    windowTitle = project.name
}

// URJ is just the shadowJar
project.task([type: Copy], 'universalReleaseJar').configure {
    dependsOn shadowJar
    def shadowJarFile = shadowJar.outputs.files.first()
    def outFile = new File(releasesBase, "${project.name}-${project.version}-universal.jar")

    from(shadowJarFile) {
        rename ".*", outFile.name
    }
    into outFile.parentFile
}

project.task("deleteExtraLaunch4jJunk").configure {
    description = "Deletes the extra launch4j lib folder"
    mustRunAfter createExe

    def lib = new File(releasesBase, "lib")
    inputs.files(lib)
    doLast {
        lib.deleteDir()
    }
}

project.task("osBundles").configure {
    dependsOn "macReleaseApp", "windowsReleaseExe", "universalReleaseJar"
    dependsOn "deleteExtraLaunch4jJunk"
}
